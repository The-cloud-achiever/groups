trigger: none

pool:
  vmImage: 'windows-latest'

variables:
- group: DL-Secrets

steps:
- checkout: self

# Download previous state/report from last successful build of pipeline 11
- task: DownloadPipelineArtifact@2
  displayName: Download Previous DL State
  continueOnError: true
  inputs:
    artifact: 'DLReport'
    path: '$(Build.SourcesDirectory)/prev'
    source: 'specific'
    project: '$(System.TeamProject)'
    pipeline: 11
    runVersion: 'latest'

# Download certificate (PFX) from Secure Files
- task: DownloadSecureFile@1
  name: fetchCert
  displayName: Download PFX certificate
  inputs:
    secureFile: 'DLTrackingCert.pfx'

# Install ExchangeOnlineManagement + Graph submodules (no meta-module)
# 1) Install modules only (do NOT Import-Module here)
- task: PowerShell@2
  displayName: 'Install modules (no imports)'
  inputs:
    targetType: inline
    pwsh: true
    script: |
      Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
      if (-not (Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue)) {
        Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
      }

      Install-Module ExchangeOnlineManagement -Scope CurrentUser -Force -AllowClobber -RequiredVersion 3.5.0 -AcceptLicense
      Install-Module Microsoft.Graph.Authentication -Scope CurrentUser -Force -AllowClobber -RequiredVersion 2.21.0 -AcceptLicense
      Install-Module Microsoft.Graph.Users.Actions  -Scope CurrentUser -Force -AllowClobber -RequiredVersion 2.21.0 -AcceptLicense

- task: PowerShell@2
  displayName: Run DL Tracking Script
  inputs:
    targetType: inline
    pwsh: true
    script: |
      # Import PFX to CurrentUser\My
      $pfxPass   = ConvertTo-SecureString $env:PFX_PASSWORD -AsPlainText -Force
      $imported  = Import-PfxCertificate -FilePath "$(fetchCert.secureFilePath)" -Password $pfxPass -CertStoreLocation Cert:\CurrentUser\My
      $thumbprint = $imported.Thumbprint

      # Paths from variable group
      $prevFile   = Join-Path "$(Build.SourcesDirectory)/prev" $env:DL_HISTORY_FILE
      $reportFile = Join-Path "$(Build.SourcesDirectory)"       $env:DL_REPORT_FILE

      if (-not (Test-Path $prevFile)) {
        '{}' | Out-File $prevFile -Encoding utf8
        Write-Host "No previous state found â€” initialized empty JSON at $prevFile"
      }

      # Quick sanity echo
      Write-Host "Using TenantId: $($env:TENANT_ID)"
      Write-Host "Report file: $reportFile"
      Write-Host "History file: $prevFile"
      Write-Host "MAIL_FROM: $($env:MAIL_FROM)"
      Write-Host "MAIL_TO: $($env:MAIL_TO)"
      Write-Host "MAIL_TO length: $([string]::IsNullOrWhiteSpace($env:MAIL_TO) ? 0 : $env:MAIL_TO.Length)"


      & "$(Build.SourcesDirectory)/Distribution_lists/DLchanges.ps1" `
        -appId      $env:APP_ID `
        -tenantId   $env:TENANT_ID `
        -orgName    $env:ORG_DOMAIN `
        -thumbprint $thumbprint `
        -previous   $prevFile `
        -report     $reportFile `
        -mailFrom   $env:MAIL_FROM `
        -mailTo     $env:MAIL_TO `
        -mailSubject $env:MAIL_SUBJECT
  env:
    # map variable-group names to environment variables
    APP_ID: $(APP_ID)
    TENANT_ID: $(TENANT_ID)
    ORG_DOMAIN: $(ORG_DOMAIN)
    PFX_PASSWORD: $(PFX_password)
    MAIL_FROM: $(MAIL_FROM)
    MAIL_TO: $(MAIL_TO)
    MAIL_SUBJECT: $(MAIL_SUBJECT)
    DL_HISTORY_FILE: $(DL_HISTORY_FILE)
    DL_REPORT_FILE: $(DL_REPORT_FILE)

# Stage outputs for next run + artifact
- task: PowerShell@2
  displayName: Move output files to folder
  inputs:
    targetType: inline
    pwsh: true
    script: |
      New-Item -ItemType Directory -Force -Path output | Out-Null
      Copy-Item -Path "$(Build.SourcesDirectory)/$env:DL_REPORT_FILE" -Destination output/ -Force
      Copy-Item -Path "$(Build.SourcesDirectory)/prev/$env:DL_HISTORY_FILE" -Destination output/ -Force

# Publish report + state so the next run can download it
- publish: output
  artifact: DLReport
  displayName: Publish Report + State Files
