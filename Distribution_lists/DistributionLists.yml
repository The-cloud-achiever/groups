trigger: none

pool:
  vmImage: 'windows-latest'

variables:
- group: DL-Secrets   # APP_ID, TENANT_ID, ORG_DOMAIN, PFX_PASSWORD, MAIL_FROM, MAIL_TO, MAIL_SUBJECT
# (optional but recommended) pin versions to avoid surprises
- name: EOMVersion
  value: '3.5.0'
- name: MGVersion
  value: '2.21.0'

steps:
- checkout: self

# Download previous snapshot & report from last successful run
- task: DownloadPipelineArtifact@2
  displayName: Download Previous DL State
  continueOnError: true
  inputs:
    artifact: 'DLReport'
    path: '$(Build.SourcesDirectory)/prev'
    source: 'specific'
    project: '$(System.TeamProject)'
    pipeline: 11
    runVersion: 'latest'

# Download the PFX used by your app (cert-based auth)
- task: DownloadSecureFile@1
  name: fetchCert
  displayName: Download PFX certificate
  inputs:
    secureFile: 'DLTrackingCert.pfx'

# Install only what we need (no caching, no big meta-module)
- task: PowerShell@2
  displayName: 'Install Modules (EXO + Graph submodules)'
  inputs:
    targetType: inline
    pwsh: true
    script: |
      $ProgressPreference = 'SilentlyContinue'

      # Make PSGallery trusted + ensure NuGet provider exists
      Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
      if (-not (Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue)) {
        Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force
      }

      $mods = @(
        @{ Name = 'ExchangeOnlineManagement';       Version = '$(EOMVersion)' },
        @{ Name = 'Microsoft.Graph.Authentication'; Version = '$(MGVersion)'  },
        @{ Name = 'Microsoft.Graph.Mail';           Version = '$(MGVersion)'  }
      )

      foreach ($m in $mods) {
        # Check if the exact version is available locally
        $have = Get-Module -ListAvailable -Name $m.Name |
                Where-Object { $_.Version -eq [version]$m.Version }

        if (-not $have) {
          Install-Module -Name $m.Name -RequiredVersion $m.Version `
            -Scope CurrentUser -Force -AllowClobber -AcceptLicense -ErrorAction Stop
        }

        Import-Module -Name $m.Name -RequiredVersion $m.Version -Force
      }


# (Optional) list scripts for quick sanity check
- task: PowerShell@2
  displayName: Debug - List all .ps1 files
  inputs:
    targetType: inline
    pwsh: true
    script: |
      Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter *.ps1

# Run the main script (build report + email via Graph app-only)
- task: PowerShell@2
  displayName: Run DL Tracking Script
  inputs:
    targetType: inline
    pwsh: true
    script: |
      # Import PFX to CurrentUser\My
      $pfxPath = "$env:PFX_PATH"
      if (-not $pfxPath) { $pfxPath = "$(fetchCert.secureFilePath)" }  # fallback if you didn't pass PFX_PATH
      $pfxPass = ConvertTo-SecureString $env:PFX_PASSWORD -AsPlainText -Force

      $imported = Import-PfxCertificate -FilePath $pfxPath -Password $pfxPass -CertStoreLocation Cert:\CurrentUser\My
      $thumbprint = $imported.Thumbprint
      Write-Host "Imported cert thumbprint: $thumbprint"

      $prevFile   = "$(Build.SourcesDirectory)/prev/previousMembers.json"
      $reportFile = "$(Build.SourcesDirectory)/DLchanges_Report.html"

      if (-not (Test-Path $prevFile)) {
        '{}' | Out-File $prevFile -Encoding utf8
        Write-Host "No previous state found â€” initialized empty JSON at $prevFile"
      }

      # Use env vars (no $() expansion issues)
      & "$(Build.SourcesDirectory)/Distribution_lists/DLchanges.ps1" `
        -appId     $env:APP_ID `
        -tenantId  $env:TENANT_ID `
        -orgName   $env:ORG_DOMAIN `
        -thumbprint $thumbprint `
        -previous  $prevFile `
        -report    $reportFile `
        -mailFrom  $env:MAIL_FROM `
        -mailTo    $env:MAIL_TO `
        -mailSubject $env:MAIL_SUBJECT
  env:
    # bind pipeline/group vars to env for the script
    APP_ID: $(APP_ID)
    TENANT_ID: $(TENANT_ID)
    ORG_DOMAIN: $(ORG_DOMAIN)
    PFX_PASSWORD: $(PFX_PASSWORD)
    MAIL_FROM: $(MAIL_FROM)
    MAIL_TO: $(MAIL_TO)
    MAIL_SUBJECT: $(MAIL_SUBJECT)



# Stage outputs for next run + artifact
- task: PowerShell@2
  displayName: Move output files to folder
  inputs:
    targetType: inline
    pwsh: true
    script: |
      New-Item -ItemType Directory -Force -Path output | Out-Null
      Move-Item -Path "$(Build.SourcesDirectory)/DLchanges_Report.html" -Destination output/ -Force
      Move-Item -Path "$(Build.SourcesDirectory)/prev/previousMembers.json" -Destination output/ -Force

# Publish report + state so the next run can download it
- publish: output
  artifact: DLReport
  displayName: Publish Report + State Files
